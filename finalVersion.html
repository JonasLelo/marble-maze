<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Marble Maze — Motion Controlled</title>
<style>
    :root{
        --bg:#0b1221;
        --play:#e9eef8;
        --ball:#2b8cff;
        --wall:#222;
        --panel:#0f1724cc;
        --text:#dfe7fb;
        --accent:#ffd166;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    .wrap{display:flex;flex-direction:column;height:100%;gap:12px;padding:12px;box-sizing:border-box;}
    header{display:flex;align-items:center;gap:12px;}
    h1{font-size:1.1rem;margin:0}
    .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    button{background:var(--panel);border:1px solid rgba(255,255,255,0.04);color:var(--text);padding:8px 10px;border-radius:8px;font-size:0.95rem}
    button.primary{background:linear-gradient(180deg,var(--accent),#ffb74d);color:#062030;font-weight:700}
    canvas{display:block;border-radius:10px;background:linear-gradient(180deg,#eaf2ff 0%, #dce9ff 100%);box-shadow:0 10px 30px rgba(0,0,0,0.6);width:100%;height:calc(100vh - 240px);max-height:680px}
    .info{font-size:0.9rem;opacity:0.95}
    .small{font-size:0.85rem;opacity:0.9}
    .visually-hidden{position:absolute!important;height:1px;width:1px;overflow:hidden;clip:rect(1px,1px,1px,1px);white-space:nowrap;border:0;padding:0;margin:-1px}
    footer{display:flex;justify-content:space-between;align-items:center;gap:12px}
    .status{font-size:0.9rem}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    label{display:inline-flex;align-items:center;gap:6px}
    input[type=range]{width:120px}
</style>
</head>
<body>
<div class="wrap">
    <header>
        <h1>Marble Maze — Motion Controlled</h1>
        <div class="controls">
            <button id="permissionBtn">Enable Motion</button>
            <button id="resetBtn">Reset Ball</button>
            <button id="soundToggle">Audio: Off</button>
            <button id="vibrateToggle">Vibrate: Off</button>
        </div>
    </header>

    <canvas id="playArea" role="img" aria-label="Play area with a single ball" tabindex="0"></canvas>

    <div class="info" id="textDescription">
        <strong>Concept (accessible):</strong>
        This digital marble simulates a small wooden box with a metal ball. Tilt your phone forward/back (beta) and left/right (gamma).
        The ball rolls in that direction, accelerates gradually, slows with friction when flat, and bounces softly on walls.
        Use the "Enable Motion" button on iOS devices to allow orientation access. Arrow keys also tilt the surface as a fallback.
    </div>

    <div class="row small">
        <label>Gravity scale<input id="gScale" type="range" min="0.5" max="6" step="0.1" value="2.0"></label>
        <label>Friction<input id="drag" type="range" min="0" max="3" step="0.05" value="1.2"></label>
        <label>Bounce<input id="restitution" type="range" min="0" max="1" step="0.05" value="0.65"></label>
    </div>

    <div aria-live="polite" id="live" class="visually-hidden"></div>

    <footer>
        <div class="status" id="status">Tilt: β=0°, γ=0° • Ball: x=0 y=0</div>
        <div class="small">Controls: Motion sensors or Arrow keys. Tap "Enable Motion" on iOS to grant permission.</div>
    </footer>
</div>

<script>
/* Marble Maze — single-file playable demo
     Features:
     - DeviceOrientation (beta: forward/back, gamma: left/right)
     - Physics: acceleration from tilt, velocity, drag (friction), soft wall bounce
     - Accessibility: descriptive text, live region updates, optional speech & vibration
     - Fallback: keyboard arrow keys simulate tilt
*/

// Canvas & sizing
const canvas = document.getElementById('playArea');
const ctx = canvas.getContext('2d');
function resize(){
    const rect = canvas.getBoundingClientRect();
    const ratio = window.devicePixelRatio || 1;
    canvas.width = Math.floor(canvas.clientWidth * ratio);
    canvas.height = Math.floor(canvas.clientHeight * ratio);
    ctx.setTransform(ratio,0,0,ratio,0,0);
    // redraw occurs in main loop
}
window.addEventListener('resize', resize);
resize();

// Simulation parameters
let ball = { x: 0, y: 0, r: 14, vx: 0, vy: 0 };
let floor = { left: 8, top: 8, right: null, bottom: null }; // set after sizing
const settings = {
    gScale: parseFloat(document.getElementById('gScale').value), // multiplier
    drag: parseFloat(document.getElementById('drag').value),      // linear drag per second
    restitution: parseFloat(document.getElementById('restitution').value), // bounce energy
};
const liveRegion = document.getElementById('live');
const status = document.getElementById('status');

function setBounds(){
    const pad = 8;
    floor.left = pad;
    floor.top = pad;
    floor.right = canvas.clientWidth - pad;
    floor.bottom = canvas.clientHeight - pad;
    // ensure ball inside
    ball.x = Math.max(floor.left + ball.r, Math.min(ball.x || (canvas.clientWidth/2), floor.right - ball.r));
    ball.y = Math.max(floor.top + ball.r, Math.min(ball.y || (canvas.clientHeight/2), floor.bottom - ball.r));
}
setBounds();

// initial ball center
if(!ball.x) ball.x = canvas.clientWidth/2;
if(!ball.y) ball.y = canvas.clientHeight/2;

// Inputs
let beta = 0;  // forward/back: positive pulls down (increase y)
let gamma = 0; // left/right: positive pulls right (increase x)
let useDevice = false;

const permissionBtn = document.getElementById('permissionBtn');
permissionBtn.addEventListener('click', async () => {
    // iOS 13+ requires permission via DeviceOrientationEvent.requestPermission
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        try {
            const res = await DeviceOrientationEvent.requestPermission();
            if (res === 'granted') {
                window.addEventListener('deviceorientation', handleOrientation);
                useDevice = true;
                permissionBtn.textContent = 'Motion Enabled';
                permissionBtn.disabled = true;
            } else {
                permissionBtn.textContent = 'Permission Denied';
            }
        } catch (e) {
            permissionBtn.textContent = 'Error';
            console.error(e);
        }
    } else {
        // Non iOS: just start listening
        window.addEventListener('deviceorientation', handleOrientation);
        useDevice = true;
        permissionBtn.textContent = 'Motion Enabled';
        permissionBtn.disabled = true;
    }
});

// Orientation handler
function handleOrientation(e){
    // Some browsers provide null values until stable; guard
    if (e.beta == null || e.gamma == null) return;
    // beta: -180..180 (forward/back), gamma: -90..90 (left/right)
    beta = clamp(e.beta, -45, 45);  // limit to reasonable range for control
    gamma = clamp(e.gamma, -45, 45);
}
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

// Keyboard fallback: arrow keys tilt the surface while pressed
const keyTilt = { up:false, down:false, left:false, right:false };
window.addEventListener('keydown', (e)=>{
    if (e.key === 'ArrowUp') keyTilt.up = true;
    if (e.key === 'ArrowDown') keyTilt.down = true;
    if (e.key === 'ArrowLeft') keyTilt.left = true;
    if (e.key === 'ArrowRight') keyTilt.right = true;
    if (!useDevice) updateFromKeys();
});
window.addEventListener('keyup', (e)=>{
    if (e.key === 'ArrowUp') keyTilt.up = false;
    if (e.key === 'ArrowDown') keyTilt.down = false;
    if (e.key === 'ArrowLeft') keyTilt.left = false;
    if (e.key === 'ArrowRight') keyTilt.right = false;
    if (!useDevice) updateFromKeys();
});
function updateFromKeys(){
    const step = 20; // degrees of tilt when fully pressed
    beta = (keyTilt.down ? step : 0) + (keyTilt.up ? -step : 0);
    gamma = (keyTilt.right ? step : 0) + (keyTilt.left ? -step : 0);
}

// UI bindings
document.getElementById('gScale').addEventListener('input', (e)=> settings.gScale = parseFloat(e.target.value));
document.getElementById('drag').addEventListener('input', (e)=> settings.drag = parseFloat(e.target.value));
document.getElementById('restitution').addEventListener('input', (e)=> settings.restitution = parseFloat(e.target.value));
document.getElementById('resetBtn').addEventListener('click', resetBall);

// Audio & vibration toggles
let audioOn = false, vibrateOn = false;
const soundToggle = document.getElementById('soundToggle');
const vibrateToggle = document.getElementById('vibrateToggle');

soundToggle.addEventListener('click', ()=>{ audioOn = !audioOn; soundToggle.textContent = 'Audio: ' + (audioOn ? 'On' : 'Off'); });
vibrateToggle.addEventListener('click', ()=>{ vibrateOn = !vibrateOn; vibrateToggle.textContent = 'Vibrate: ' + (vibrateOn ? 'On' : 'Off'); });

// Simple collision sound using WebAudio
let audioCtx = null;
function hitSound(volume=0.3){
    if(!audioOn) return;
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine';
    o.frequency.setValueAtTime(220, audioCtx.currentTime);
    g.gain.setValueAtTime(volume, audioCtx.currentTime);
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.15);
    o.stop(audioCtx.currentTime + 0.16);
}

// Reset function
function resetBall(){
    ball.x = (floor.left + floor.right) / 2;
    ball.y = (floor.top + floor.bottom) / 2;
    ball.vx = 0; ball.vy = 0;
    announce('Ball reset to center.');
}

// Physics loop
let last = performance.now();
let liveThrottle = 0;
let lastCollisionTime = 0;
function step(now){
    const dt = Math.min(0.05, (now - last) / 1000); // cap dt to avoid jumps
    last = now;

    // Accelerations from tilt:
    // Convert degrees to radians and use sin to get small-angle behavior.
    const g = 9.81; // m/s^2 baseline (for feel)
    const ax = g * Math.sin(gamma * Math.PI / 180) * settings.gScale;
    const ay = g * Math.sin(beta  * Math.PI / 180) * settings.gScale;

    // Integrate velocity
    ball.vx += ax * dt;
    ball.vy += ay * dt;

    // Apply linear drag (simple damping per second)
    const dragFactor = Math.max(0, 1 - settings.drag * dt);
    ball.vx *= dragFactor;
    ball.vy *= dragFactor;

    // Integrate position
    ball.x += ball.vx * (50 * dt); // scale factor so world units feel like screen px
    ball.y += ball.vy * (50 * dt);

    // Collisions with soft bounce
    const nowTs = performance.now();
    let collided = false;
    // left
    if (ball.x - ball.r < floor.left){
        ball.x = floor.left + ball.r;
        if (ball.vx < 0) ball.vx = -ball.vx * settings.restitution;
        // slight tangential damping
        ball.vy *= 0.98;
        collided = true;
        collisionLabel('left');
    }
    // right
    if (ball.x + ball.r > floor.right){
        ball.x = floor.right - ball.r;
        if (ball.vx > 0) ball.vx = -ball.vx * settings.restitution;
        ball.vy *= 0.98;
        collided = true;
        collisionLabel('right');
    }
    // top
    if (ball.y - ball.r < floor.top){
        ball.y = floor.top + ball.r;
        if (ball.vy < 0) ball.vy = -ball.vy * settings.restitution;
        ball.vx *= 0.98;
        collided = true;
        collisionLabel('top');
    }
    // bottom
    if (ball.y + ball.r > floor.bottom){
        ball.y = floor.bottom - ball.r;
        if (ball.vy > 0) ball.vy = -ball.vy * settings.restitution;
        ball.vx *= 0.98;
        collided = true;
        collisionLabel('bottom');
    }

    // Render
    render();

    // Live accessibility updates (throttled)
    liveThrottle += dt;
    if (liveThrottle > 0.18){ // ~5-6 updates per second
        liveThrottle = 0;
        const bx = Math.round(ball.x - floor.left);
        const by = Math.round(ball.y - floor.top);
        status.textContent = `Tilt: β=${Math.round(beta)}°, γ=${Math.round(gamma)}° • Ball: x=${bx} y=${by}`;
        liveRegion.textContent = `Tilt beta ${Math.round(beta)} degrees, gamma ${Math.round(gamma)} degrees. Ball position ${bx} by ${by} pixels.`;
    }

    requestAnimationFrame(step);
}
requestAnimationFrame(step);

// Collision helper to avoid repeating announcements
function collisionLabel(side){
    const now = performance.now();
    if (now - lastCollisionTime < 180) return; // throttle collisions
    lastCollisionTime = now;
    if (audioOn) hitSound(0.25);
    if (vibrateOn && navigator.vibrate) navigator.vibrate(40);
    announce('Collision ' + side + ' wall.');
}

// Simple speech synthesis for announcements (toggle via audioOn)
function announce(text){
    // Do not spam; if audioOn tie it to speech toggle, else only live region
    // We'll announce short sentences when audioOn is true
    if (!audioOn) return;
    if ('speechSynthesis' in window){
        const u = new SpeechSynthesisUtterance(text);
        u.lang = 'en-US';
        u.rate = 1;
        window.speechSynthesis.cancel();
        window.speechSynthesis.speak(u);
    }
}

// Drawing routine
function render(){
    // Clear
    ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);

    // Draw playfield (rounded rect)
    const pad = 8;
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    const radius = 12;

    // Outer shadow/wall
    ctx.save();
    ctx.fillStyle = '#0b1221';
    ctx.fillRect(0,0,w,h);
    ctx.restore();

    // Floor area
    ctx.save();
    ctx.beginPath();
    roundRect(ctx, floor.left, floor.top, floor.right - floor.left, floor.bottom - floor.top, radius);
    ctx.fillStyle = '#f7fbff';
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.15)';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.restore();

    // Draw subtle grid lines to give tactile sense
    ctx.save();
    ctx.strokeStyle = 'rgba(0,0,0,0.02)';
    ctx.lineWidth = 1;
    const grid = 40;
    for (let gx = floor.left + grid; gx < floor.right; gx += grid){
        ctx.beginPath(); ctx.moveTo(gx, floor.top); ctx.lineTo(gx, floor.bottom); ctx.stroke();
    }
    for (let gy = floor.top + grid; gy < floor.bottom; gy += grid){
        ctx.beginPath(); ctx.moveTo(floor.left, gy); ctx.lineTo(floor.right, gy); ctx.stroke();
    }
    ctx.restore();

    // Draw ball shadow
    ctx.save();
    ctx.beginPath();
    ctx.ellipse(ball.x + 5, ball.y + 8, ball.r*0.9, ball.r*0.35, 0, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(0,0,0,0.18)';
    ctx.fill();
    ctx.restore();

    // Draw ball (metallic look)
    ctx.save();
    const grad = ctx.createRadialGradient(ball.x - ball.r*0.3, ball.y - ball.r*0.4, ball.r*0.2, ball.x, ball.y, ball.r);
    grad.addColorStop(0, '#ffffff');
    grad.addColorStop(0.3, '#cfe7ff');
    grad.addColorStop(0.9, '#2b8cff');
    grad.addColorStop(1, '#174f9a');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
    ctx.fill();

    // specular highlight
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,255,255,0.7)';
    ctx.ellipse(ball.x - ball.r*0.25, ball.y - ball.r*0.4, ball.r*0.35, ball.r*0.22, -0.6, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // Debug info (small)
    //ctx.fillStyle = 'rgba(0,0,0,0.6)';
    //ctx.fillText(`v=${ball.vx.toFixed(2)},${ball.vy.toFixed(2)}`, 12, 20);
}

// Round rect helper
function roundRect(ctx, x, y, w, h, r){
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
}

// On initial load, center ball relative to initial canvas size
setBounds();
resetBall();

// Informative console for debugging
console.info('Marble Maze initialized. Use device tilt or arrow keys.');

// Accessibility: focus canvas and announce startup
canvas.addEventListener('focus', ()=> {
    liveRegion.textContent = 'Play area focused. Use device tilt or arrow keys to move the ball.';
});

// Ensure bounds update on window resize
window.addEventListener('resize', ()=> { resize(); setBounds(); });

// Prevent scrolling on touch while interacting with the canvas (improves mobile feel)
let touching = false;
canvas.addEventListener('touchstart', (e)=>{ touching=true; }, {passive:false});
canvas.addEventListener('touchend', ()=>{ touching=false; }, {passive:false});
window.addEventListener('touchmove', (e)=>{ if (touching) e.preventDefault(); }, {passive:false});
</script>
</body>
</html></div>Marble</div>