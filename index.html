<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Marble Maze</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
html,body{height:100%;margin:0;background:#efe7d6;display:flex;align-items:center;justify-content:center;font-family:system-ui,Segoe UI,Roboto}
#game{position:relative}
canvas{background:linear-gradient(#c7a77a,#b88950);display:block;border:6px solid #5b3a21;box-shadow:0 8px 24px rgba(0,0,0,.35)}
#ui{position:absolute;left:8px;top:8px;color:#fff;display:flex;gap:8px}
button{background:#333;color:#fff;border:none;padding:6px 10px;border-radius:6px;cursor:pointer}
#msg{position:absolute;right:8px;top:8px;background:rgba(0,0,0,.6);color:#fff;padding:8px 12px;border-radius:6px}
#legend{position:absolute;left:8px;bottom:8px;background:rgba(0,0,0,.6);color:#fff;padding:6px 10px;border-radius:6px;font-size:13px}
</style>
</head>
<body>
<div id="game">
    <canvas id="c" width="720" height="720"></canvas>
    <div id="ui">
        <button id="restart">Restart</button>
        <button id="toggle-trace">Toggle Trace</button>
    </div>
    <div id="msg">Use arrow keys, drag, or tilt. Reach the spiral. Avoid black holes.</div>
    <div id="legend">Holes = black • Goal = spiral</div>
</div>

<script>
/* ============================================================
   MARBLE MAZE – COMPLETE GAME WITH CORRECT AXIS SWAP
   ============================================================ */

/* ---------- MAZE DEFINITION ---------- */
const MAZE = [
 "W W W W W W W W W W",
 "W . . . . W . . . W",
 "W . . O . W . . . W",
 "W . W W . W . W . W",
 "W . W G . . . W . W",
 "W . W W W W . W . W",
 "W . . . . W . W . W",
 "W W W W . W . W . W",
 "W S . . . . . O . W",
 "W W W W W W . . . W",
 "W W W W W W W W W W"
].map(r => r.split(' '));

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let rows = MAZE.length;
let cols = MAZE[0].length;
let tileSize = Math.min(canvas.width/cols, canvas.height/rows);
let radius = tileSize * 0.35;

function findTile(ch){
    for(let y=0;y<rows;y++)
        for(let x=0;x<cols;x++)
            if(MAZE[y][x]===ch) return {x,y};
}
function findAllTiles(ch){
    const out=[];
    for(let y=0;y<rows;y++)
        for(let x=0;x<cols;x++)
            if(MAZE[y][x]===ch) out.push({x,y});
    return out;
}

const startPos = findTile('S');
const goalPos = findTile('G');
const holeTiles = findAllTiles('O');

/* ---------- BALL STATE ---------- */
let ball = {
    x:(startPos.x+0.5)*tileSize,
    y:(startPos.y+0.5)*tileSize,
    vx:0,
    vy:0,
    r:radius,
};

const state = {
    running:true,
    trace:false,
    message:'',
    path:[],
    lastTime:null
};

/* ---------- PHYSICS PARAMETERS ---------- */
const friction = 0.98;
const maxSpeed = 800;
const accPower = 1800;

/* ---------- INPUT ---------- */
let input = {ax:0, ay:0};
const keys = {left:false, right:false, up:false, down:false};
const pointer = {down:false, startX:0, startY:0};

/* ============================================================
   MOVEMENT CONTROL (AXES SWAPPED)
   ============================================================ */

let gravityX = 0;
let gravityY = 0;

/* ----- Device Tilt (gamma & beta swapped!) ----- */
if (window.DeviceOrientationEvent) {
    window.addEventListener("deviceorientation", e => {
        if (e.gamma == null || e.beta == null) return;

        /* SWAPPED AXES */
        gravityX = -e.beta / 45;   // previously gamma
        gravityY =  e.gamma / 45;  // previously beta
    });
} else {
    /* Mouse fallback */
    window.addEventListener("mousemove", e => {
        const rect = canvas.getBoundingClientRect();
        const cx = rect.left + rect.width/2;
        const cy = rect.top + rect.height/2;
        gravityX = (e.clientX - cx) / (rect.width/2);
        gravityY = (e.clientY - cy) / (rect.height/2);
    });
}

/* ============================================================
   DRAWING – unchanged
   ============================================================ */

function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    for(let y=0;y<rows;y++){
        for(let x=0;x<cols;x++){
            const px=x*tileSize, py=y*tileSize;
            const t=MAZE[y][x];

            if(t==='W'){
                ctx.fillStyle='#6b4a2b';
                ctx.fillRect(px,py,tileSize,tileSize);
                ctx.fillStyle='#8f6237';
                ctx.fillRect(px+2,py+2,tileSize-4,tileSize-4);
            } else {
                ctx.fillStyle='#d9c7a6';
                ctx.fillRect(px,py,tileSize,tileSize);
            }

            if(t==='O') drawHole(px+tileSize/2, py+tileSize/2, tileSize*0.4);
            if(t==='G') drawSpiral(px+tileSize/2, py+tileSize/2, tileSize*0.42);
        }
    }

    if(state.trace && state.path.length>1){
        ctx.beginPath();
        ctx.strokeStyle='rgba(0,0,0,0.2)';
        ctx.lineWidth=2;
        ctx.moveTo(state.path[0].x,state.path[0].y);
        for(let p of state.path) ctx.lineTo(p.x,p.y);
        ctx.stroke();
    }

    drawBall();

    document.getElementById("msg").textContent =
        state.message || "Use arrow keys, drag, or tilt. Reach the spiral. Avoid black holes.";
}

function drawBall(){
    const g=ctx.createRadialGradient(
        ball.x-ball.r*0.3,
        ball.y-ball.r*0.3,
        ball.r*0.1,
        ball.x, ball.y, ball.r
    );
    g.addColorStop(0,'#fff');
    g.addColorStop(0.2,'#dfe8f2');
    g.addColorStop(1,'#7a7f85');

    ctx.fillStyle=g;
    ctx.beginPath();
    ctx.arc(ball.x,ball.y,ball.r,0,Math.PI*2);
    ctx.fill();

    ctx.strokeStyle='rgba(255,255,255,0.15)';
    ctx.lineWidth=1;
    ctx.stroke();
}

function drawHole(cx,cy,r){
    const g=ctx.createRadialGradient(cx-r*0.2,cy-r*0.2,1,cx,cy,r);
    g.addColorStop(0,'#111');
    g.addColorStop(1,'#000');
    ctx.fillStyle=g;
    ctx.beginPath();
    ctx.arc(cx,cy,r,0,Math.PI*2);
    ctx.fill();
}

function drawSpiral(cx,cy,r){
    const grad=ctx.createLinearGradient(cx-r,cy-r,cx+r,cy+r);
    grad.addColorStop(0,'#ffeaa7');
    grad.addColorStop(1,'#ffd07a');
    ctx.fillStyle=grad;
    ctx.beginPath();
    ctx.arc(cx,cy,r,0,Math.PI*2);
    ctx.fill();

    ctx.save();
    ctx.translate(cx,cy);
    ctx.strokeStyle='#6b3d00';
    ctx.lineWidth=Math.max(2,r*0.08);
    ctx.beginPath();
    for(let i=0;i<120;i++){
        const t=i/120;
        const a=t*5*Math.PI*2 - Math.PI/2;
        const rad=r*(1 - t*0.9);
        const x=Math.cos(a)*rad;
        const y=Math.sin(a)*rad;
        if(i==0) ctx.moveTo(x,y);
        else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.restore();
}

/* ============================================================
   PHYSICS (unchanged)
   ============================================================ */

function physics(dt){
    let ax = -gravityX * accPower;
    let ay = -gravityY * accPower;

    if(keys.left)  ax -= accPower;
    if(keys.right) ax += accPower;
    if(keys.up)    ay -= accPower;
    if(keys.down)  ay += accPower;

    ax += input.ax;
    ay += input.ay;

    ball.vx += ax * dt;
    ball.vy += ay * dt;

    const s = Math.hypot(ball.vx, ball.vy);
    if(s > maxSpeed){
        const k = maxSpeed/s;
        ball.vx *= k;
        ball.vy *= k;
    }

    ball.vx *= Math.pow(friction, dt*60);
    ball.vy *= Math.pow(friction, dt*60);

    ball.x += ball.vx * dt;
    ball.y += ball.vy * dt;

    resolveWallCollisions();

    for(const h of holeTiles){
        const cx=(h.x+0.5)*tileSize, cy=(h.y+0.5)*tileSize;
        if(Math.hypot(ball.x-cx,ball.y-cy)<tileSize*0.35)
            return lost();
    }

    const gx=(goalPos.x+0.5)*tileSize, gy=(goalPos.y+0.5)*tileSize;
    if(Math.hypot(ball.x-gx,ball.y-gy)<tileSize*0.35)
        return win();

    if(state.trace){
        if(state.path.length===0 ||
            Math.hypot(ball.x-state.path.at(-1).x,ball.y-state.path.at(-1).y)>6)
            state.path.push({x:ball.x,y:ball.y});
        if(state.path.length>800) state.path.shift();
    }
}

/* ---------- Wall Collisions ---------- */
function resolveWallCollisions(){
    const minX=Math.floor((ball.x-ball.r)/tileSize);
    const maxX=Math.floor((ball.x+ball.r)/tileSize);
    const minY=Math.floor((ball.y-ball.r)/tileSize);
    const maxY=Math.floor((ball.y+ball.r)/tileSize);

    for(let ty=minY;ty<=maxY;ty++){
        for(let tx=minX;tx<=maxX;tx++){
            if(ty<0||ty>=rows||tx<0||tx>=cols) continue;
            if(MAZE[ty][tx]!=='W') continue;

            const rx=tx*tileSize, ry=ty*tileSize;

            const closestX=Math.max(rx, Math.min(ball.x, rx+tileSize));
            const closestY=Math.max(ry, Math.min(ball.y, ry+tileSize));

            const dx=ball.x-closestX;
            const dy=ball.y-closestY;
            const dist2=dx*dx+dy*dy;

            if(dist2 < ball.r*ball.r){
                const dist=Math.sqrt(dist2)||0.001;
                const overlap=ball.r-dist;

                const nx=dx/dist, ny=dy/dist;

                ball.x += nx*overlap;
                ball.y += ny*overlap;

                const vdot = ball.vx*nx + ball.vy*ny;
                ball.vx -= 1.6*vdot*nx;
                ball.vy -= 1.6*vdot*ny;

                ball.vx *= 0.75;
                ball.vy *= 0.75;
            }
        }
    }
}

/* ============================================================
   GAME STATE
   ============================================================ */

function resetBall(){
    ball.x=(startPos.x+0.5)*tileSize;
    ball.y=(startPos.y+0.5)*tileSize;
    ball.vx=0;
    ball.vy=0;
    state.message='';
    state.path=[];
}

function lost(){
    state.message='Fell into a hole! Restarting…';
    setTimeout(resetBall,800);
}

function win(){
    state.message='You reached the spiral! Congratulations.';
    ball.vx=ball.vy=0;
    setTimeout(resetBall,1500);
}

/* ============================================================
   INPUT EVENTS
   ============================================================ */

window.addEventListener('keydown', e=>{
    if(e.key==="ArrowLeft"||e.key==="a"){ keys.left=true; e.preventDefault(); }
    if(e.key==="ArrowRight"||e.key==="d"){ keys.right=true; e.preventDefault(); }
    if(e.key==="ArrowUp"||e.key==="w"){ keys.up=true; e.preventDefault(); }
    if(e.key==="ArrowDown"||e.key==="s"){ keys.down=true; e.preventDefault(); }
});
window.addEventListener('keyup', e=>{
    if(e.key==="ArrowLeft"||e.key==="a") keys.left=false;
    if(e.key==="ArrowRight"||e.key==="d") keys.right=false;
    if(e.key==="ArrowUp"||e.key==="w") keys.up=false;
    if(e.key==="ArrowDown"||e.key==="s") keys.down=false;
});

/* Pointer drag tilt */
canvas.addEventListener('pointerdown', e=>{
    pointer.down=true;
    pointer.startX=e.clientX;
    pointer.startY=e.clientY;
    canvas.setPointerCapture(e.pointerId);
});
canvas.addEventListener('pointermove', e=>{
    if(!pointer.down) return;
    input.ax=(e.clientX-pointer.startX)*12;
    input.ay=(e.clientY-pointer.startY)*12;
});
canvas.addEventListener('pointerup', e=>{
    pointer.down=false;
    input.ax=input.ay=0;
    canvas.releasePointerCapture?.(e.pointerId);
});

/* ============================================================
   LOOP
   ============================================================ */

function step(now){
    if(!state.lastTime) state.lastTime=now;
    const dt=Math.min(0.03,(now-state.lastTime)/1000);
    state.lastTime=now;

    physics(dt);
    draw();

    requestAnimationFrame(step);
}

/* UI */
document.getElementById('restart').onclick=resetBall;
document.getElementById('toggle-trace').onclick=()=>state.trace=!state.trace;

/* Resize */
function adjustCanvas(){
    const sz=Math.min(window.innerWidth-40,window.innerHeight-40,720);
    canvas.width=sz;
    canvas.height=sz;
    tileSize=Math.min(canvas.width/cols,canvas.height/rows);
    radius=tileSize*0.35;
    ball.r=radius;
}
window.addEventListener('resize', adjustCanvas);

/* START */
adjustCanvas();
resetBall();
requestAnimationFrame(step);
</script>
</body>
</html>
