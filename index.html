<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Marble Maze</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
html,body{height:100%;margin:0;background:#efe7d6;display:flex;align-items:center;justify-content:center;font-family:system-ui,Segoe UI,Roboto}
#game{position:relative;display:none;}
canvas{background:linear-gradient(#c7a77a,#b88950);display:block;border:6px solid #5b3a21;box-shadow:0 8px 24px rgba(0,0,0,.35)}
#ui{position:absolute;left:8px;top:8px;color:#fff;display:flex;gap:8px}
button{background:#333;color:#fff;border:none;padding:6px 10px;border-radius:6px;cursor:pointer}
#msg{position:absolute;right:8px;top:8px;background:rgba(0,0,0,.6);color:#fff;padding:8px 12px;border-radius:6px}
#legend{position:absolute;left:8px;bottom:8px;background:rgba(0,0,0,.6);color:#fff;padding:6px 10px;border-radius:6px;font-size:13px}

/* Starting screen */
#start-screen{
    position:absolute;
    top:0; left:0;
    width:100%; height:100%;
    background:rgba(0,0,0,0.8);
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    color:#fff;
}
#start-screen h1{margin-bottom:20px}
.maze-option{
    background:#333;
    margin:10px;
    padding:10px;
    border-radius:8px;
    cursor:pointer;
    display:flex;
    flex-direction:column;
    align-items:center;
    transition: transform 0.2s, box-shadow 0.2s;
}
.maze-option:hover{
    transform: scale(1.05);
    box-shadow:0 0 20px rgba(255,255,255,0.5);
}
.maze-option canvas{
    border:2px solid #fff;
    margin-bottom:8px;
}
.difficulty-label{
    font-weight:bold;
    font-size:14px;
}
.options-container{display:flex; flex-wrap:wrap; justify-content:center;}
</style>
</head>
<body>

<div id="start-screen">
    <h1>Select a Maze</h1>
    <div class="options-container">
        <div class="maze-option" data-maze="0">
            <canvas id="preview0" width="100" height="100"></canvas>
            <div class="difficulty-label">Easy</div>
        </div>
        <div class="maze-option" data-maze="1">
            <canvas id="preview1" width="100" height="100"></canvas>
            <div class="difficulty-label">Medium</div>
        </div>
        <div class="maze-option" data-maze="2">
            <canvas id="preview2" width="100" height="100"></canvas>
            <div class="difficulty-label">Hard</div>
        </div>
    </div>
</div>

<div id="game">
    <canvas id="c" width="720" height="720"></canvas>
    <div id="ui">
        <button id="restart">Restart</button>
        <button id="toggle-trace">Toggle Trace</button>
    </div>
    <div id="msg">Use arrow keys, drag, or tilt. Reach the spiral. Avoid black holes.</div>
    <div id="legend">Holes = black • Goal = spiral</div>
</div>

<script>
/* ===================== MAZES ===================== */
const MAZES = [];

// Example Maze 1 (replace with your data)
MAZES.push([
 "W W W W W W W W W W",
 "W S . . . W . . . W",
 "W . . O . W . . . W",
 "W . W W . W . W . W",
 "W . W G . . . W . W",
 "W . W W W W . W . W",
 "W . . . . W . W . W",
 "W W W W . W . W . W",
 "W . . . . . . O . W",
 "W W W W W W . . . W",
 "W W W W W W W W W W"
].map(r=>r.split(' ')));

// Example Maze 2
MAZES.push([
 "W W W W W W W W W W",
 "W S . W . . . W . W",
 "W W . W O W . W . W",
 "W . . . . W . W . W",
 "W . W W W W . W G W",
 "W . W O . . . . W W",
 "W . W W W W W W W W",
 "W . . . O . . . . W",
 "W W W W W W W W . W",
 "W W W W W W W W W W"
].map(r=>r.split(' ')));

// Example Maze 3
MAZES.push([
 "W W W W W W W W W W",
 "W S . W . . . O . W",
 "W W . W W W . W . W",
 "W . . . O W . W . W",
 "W . W W . W . W G W",
 "W . W . . . . W . W",
 "W . W W W O W W . W",
 "W . . . . . . . . W",
 "W W W W W W W W . W",
 "W W W W W W W W W W"
].map(r=>r.split(' ')));

/* ============ GAME VARIABLES ============ */
let MAZE, rows, cols, tileSize, radius;
let startPos, goalPos, holeTiles;
let ball = {x:0,y:0,vx:0,vy:0,r:0};
const state={running:true,trace:false,message:'',path:[],lastTime:null};
const input={ax:0,ay:0};
const keys={left:false,right:false,up:false,down:false};
const pointer={down:false,startX:0,startY:0};
let gravityX=0,gravityY=0;

/* ============ START SCREEN LOGIC ============ */
const startScreen = document.getElementById('start-screen');
const mazeOptions = document.querySelectorAll('.maze-option');

mazeOptions.forEach(opt=>{
    opt.addEventListener('click',()=>{
        const idx = parseInt(opt.dataset.maze);
        loadMaze(idx);
        startScreen.style.display='none';
        document.getElementById('game').style.display='block';
        adjustCanvas();
        resetBall();
        requestAnimationFrame(step);
    });
});

/* ============ LOAD SELECTED MAZE ============ */
function loadMaze(idx){
    MAZE = MAZES[idx];
    rows = MAZE.length;
    cols = MAZE[0].length;
    tileSize = Math.min(720/cols,720/rows);
    radius = tileSize*0.35;
    startPos = findTile('S');
    goalPos = findTile('G');
    holeTiles = findAllTiles('O');
    ball = {x:(startPos.x+0.5)*tileSize, y:(startPos.y+0.5)*tileSize, vx:0, vy:0, r:radius};
}

/* ============ HELPERS ============ */
function findTile(ch){
    for(let y=0;y<rows;y++)
        for(let x=0;x<cols;x++)
            if(MAZE[y][x]===ch) return {x,y};
}
function findAllTiles(ch){
    const out=[]; for(let y=0;y<rows;y++) for(let x=0;x<cols;x++) if(MAZE[y][x]===ch) out.push({x,y}); return out;
}

/* ============ PREVIEW CANVAS DRAWING ============ */
function drawPreview(maze,canvas){
    const ctx = canvas.getContext('2d');
    const w = canvas.width, h = canvas.height;
    const rows = maze.length, cols = maze[0].length;
    const ts = Math.min(w/cols,h/rows);
    ctx.clearRect(0,0,w,h);

    for(let y=0;y<rows;y++){
        for(let x=0;x<cols;x++){
            const t = maze[y][x];
            const px=x*ts, py=y*ts;
            if(t==='W'){ ctx.fillStyle='#6b4a2b'; ctx.fillRect(px,py,ts,ts);}
            else if(t==='O'){ ctx.fillStyle='#111'; ctx.fillRect(px,py,ts,ts);}
            else if(t==='G'){ ctx.fillStyle='#ffeaa7'; ctx.fillRect(px,py,ts,ts);}
            else if(t==='S'){ ctx.fillStyle='#4caf50'; ctx.fillRect(px,py,ts,ts);}
            else ctx.fillStyle='#d9c7a6',ctx.fillRect(px,py,ts,ts);
        }
    }
}
drawPreview(MAZES[0],document.getElementById('preview0'));
drawPreview(MAZES[1],document.getElementById('preview1'));
drawPreview(MAZES[2],document.getElementById('preview2'));

/* ============ DEVICE / MOUSE INPUT ============ */
if(window.DeviceOrientationEvent){
    window.addEventListener("deviceorientation", e=>{
        if(e.gamma==null||e.beta==null) return;
        gravityX = -e.beta/45;
        gravityY = e.gamma/45;
    });
} else {
    const canvasEl=document.getElementById('c');
    canvasEl.addEventListener('mousemove',e=>{
        const rect = canvasEl.getBoundingClientRect();
        const cx=rect.left+rect.width/2;
        const cy=rect.top+rect.height/2;
        gravityX=(e.clientX-cx)/(rect.width/2);
        gravityY=(e.clientY-cy)/(rect.height/2);
    });
}

/* ============ KEYBOARD INPUT ============ */
window.addEventListener('keydown', e=>{
    if(e.key==="ArrowLeft"||e.key==="a"){ keys.left=true; e.preventDefault();}
    if(e.key==="ArrowRight"||e.key==="d"){ keys.right=true; e.preventDefault();}
    if(e.key==="ArrowUp"||e.key==="w"){ keys.up=true; e.preventDefault();}
    if(e.key==="ArrowDown"||e.key==="s"){ keys.down=true; e.preventDefault();}
});
window.addEventListener('keyup', e=>{
    if(e.key==="ArrowLeft"||e.key==="a") keys.left=false;
    if(e.key==="ArrowRight"||e.key==="d") keys.right=false;
    if(e.key==="ArrowUp"||e.key==="w") keys.up=false;
    if(e.key==="ArrowDown"||e.key==="s") keys.down=false;
});

/* ============ POINTER DRAG ============ */
const canvasEl=document.getElementById('c');
canvasEl.addEventListener('pointerdown', e=>{pointer.down=true;pointer.startX=e.clientX;pointer.startY=e.clientY;canvasEl.setPointerCapture(e.pointerId);});
canvasEl.addEventListener('pointermove', e=>{if(!pointer.down) return; input.ax=(e.clientX-pointer.startX)*12; input.ay=(e.clientY-pointer.startY)*12;});
canvasEl.addEventListener('pointerup', e=>{pointer.down=false; input.ax=input.ay=0; canvasEl.releasePointerCapture?.(e.pointerId);});

/* ============ UI BUTTONS ============ */
document.getElementById('restart').onclick=()=>resetBall();
document.getElementById('toggle-trace').onclick=()=>state.trace=!state.trace;

/* ============ CANVAS RESIZE ============ */
function adjustCanvas(){
    const sz=Math.min(window.innerWidth-40,window.innerHeight-40,720);
    canvasEl.width=sz; canvasEl.height=sz;
    tileSize=Math.min(canvasEl.width/cols,canvasEl.height/rows);
    radius=tileSize*0.35; ball.r=radius;
}
window.addEventListener('resize', adjustCanvas);

/* ============ DRAWING FUNCTIONS ============ */
function draw(){
    const ctx = canvasEl.getContext('2d');
    ctx.clearRect(0,0,canvasEl.width,canvasEl.height);
    for(let y=0;y<rows;y++){
        for(let x=0;x<cols;x++){
            const px=x*tileSize, py=y*tileSize;
            const t=MAZE[y][x];
            if(t==='W'){ ctx.fillStyle='#6b4a2b'; ctx.fillRect(px,py,tileSize,tileSize);}
            else{ ctx.fillStyle='#d9c7a6'; ctx.fillRect(px,py,tileSize,tileSize);}
            if(t==='O') drawHole(px+tileSize/2,py+tileSize/2,tileSize*0.4);
            if(t==='G') drawSpiral(px+tileSize/2,py+tileSize/2,tileSize*0.42);
        }
    }
    if(state.trace && state.path.length>1){
        ctx.beginPath(); ctx.strokeStyle='rgba(0,0,0,0.2)'; ctx.lineWidth=2;
        ctx.moveTo(state.path[0].x,state.path[0].y);
        for(let p of state.path) ctx.lineTo(p.x,p.y); ctx.stroke();
    }
    drawBall();
    document.getElementById("msg").textContent= state.message || "Use arrow keys, drag, or tilt. Reach the spiral. Avoid black holes.";
}
function drawBall(){
    const ctx = canvasEl.getContext('2d');
    const g=ctx.createRadialGradient(ball.x-ball.r*0.3,ball.y-ball.r*0.3,ball.r*0.1,ball.x,ball.y,ball.r);
    g.addColorStop(0,'#fff'); g.addColorStop(0.2,'#dfe8f2'); g.addColorStop(1,'#7a7f85');
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(ball.x,ball.y,ball.r,0,Math.PI*2); ctx.fill();
}
function drawHole(cx,cy,r){const ctx = canvasEl.getContext('2d'); ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();}
function drawSpiral(cx,cy,r){const ctx = canvasEl.getContext('2d'); ctx.fillStyle='#ffd07a'; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();}

/* ============ PHYSICS ============ */
const friction=0.98, maxSpeed=800, accPower=1800;
function physics(dt){
    let ax=-gravityX*accPower+input.ax, ay=-gravityY*accPower+input.ay;
    if(keys.left) ax-=accPower; if(keys.right) ax+=accPower; if(keys.up) ay-=accPower; if(keys.down) ay+=accPower;
    ball.vx+=ax*dt; ball.vy+=ay*dt;
    const s=Math.hypot(ball.vx,ball.vy); if(s>maxSpeed){ const k=maxSpeed/s; ball.vx*=k; ball.vy*=k;}
    ball.vx*=Math.pow(friction,dt*60); ball.vy*=Math.pow(friction,dt*60);
    ball.x+=ball.vx*dt; ball.y+=ball.vy*dt;
    resolveWallCollisions();
    for(const h of holeTiles){
        const cx=(h.x+0.5)*tileSize, cy=(h.y+0.5)*tileSize;
        if(Math.hypot(ball.x-cx,ball.y-cy)<tileSize*0.35) return lost();
    }
    const gx=(goalPos.x+0.5)*tileSize, gy=(goalPos.y+0.5)*tileSize;
    if(Math.hypot(ball.x-gx,ball.y-gy)<tileSize*0.35) return win();
    if(state.trace){
        if(state.path.length===0 || Math.hypot(ball.x-state.path.at(-1).x,ball.y-state.path.at(-1).y)>6)
            state.path.push({x:ball.x,y:ball.y});
        if(state.path.length>800) state.path.shift();
    }
}

/* ============ COLLISIONS ============ */
function resolveWallCollisions(){
    const minX=Math.floor((ball.x-ball.r)/tileSize), maxX=Math.floor((ball.x+ball.r)/tileSize);
    const minY=Math.floor((ball.y-ball.r)/tileSize), maxY=Math.floor((ball.y+ball.r)/tileSize);
    const ctx = canvasEl.getContext('2d');
    for(let ty=minY;ty<=maxY;ty++) for(let tx=minX;tx<=maxX;tx++){
        if(ty<0||ty>=rows||tx<0||tx>=cols) continue; if(MAZE[ty][tx]!=='W') continue;
        const rx=tx*tileSize, ry=ty*tileSize;
        const closestX=Math.max(rx, Math.min(ball.x, rx+tileSize));
        const closestY=Math.max(ry, Math.min(ball.y, ry+tileSize));
        const dx=ball.x-closestX, dy=ball.y-closestY, dist2=dx*dx+dy*dy;
        if(dist2<ball.r*ball.r){
            const dist=Math.sqrt(dist2)||0.001; const overlap=ball.r-dist;
            const nx=dx/dist, ny=dy/dist;
            ball.x+=nx*overlap; ball.y+=ny*overlap;
            const vdot=ball.vx*nx+ball.vy*ny;
            ball.vx-=1.6*vdot*nx; ball.vy-=1.6*vdot*ny;
            ball.vx*=0.75; ball.vy*=0.75;
        }
    }
}

/* ============ GAME STATE ============ */
function resetBall(){ ball.x=(startPos.x+0.5)*tileSize; ball.y=(startPos.y+0.5)*tileSize; ball.vx=0; ball.vy=0; state.message=''; state.path=[];}
function lost(){ state.message='Fell into a hole! Restarting…'; setTimeout(resetBall,800);}
function win(){ state.message='You reached the spiral! Congratulations.'; ball.vx=ball.vy=0; setTimeout(resetBall,1500);}

/* ============ MAIN LOOP ============ */
function step(now){
    if(!state.lastTime) state.lastTime=now;
    const dt=Math.min(0.03,(now-state.lastTime)/1000); state.lastTime=now;
    physics(dt); draw();
    requestAnimationFrame(step);
}
</script>
</body>
</html>
