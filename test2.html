<!doctype html>
<!-- Save as test2.html -->
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Marble Maze â€” Tilt Physics Toy</title>
<style>
    html,body { height:100%; margin:0; background:#111; color:#eee; font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial; -webkit-font-smoothing:antialiased; display:flex; align-items:center; justify-content:center; }
    #wrapper { width:100%; max-width:900px; aspect-ratio:1/1; position:relative; }
    canvas { width:100%; height:100%; display:block; background:linear-gradient(180deg,#222,#0a0a0a); border-radius:14px; box-shadow:0 8px 30px rgba(0,0,0,0.7), inset 0 1px 0 rgba(255,255,255,0.02); touch-action:none; -webkit-user-select:none; user-select:none; }
    .ui { position:absolute; left:10px; top:10px; display:flex; gap:8px; align-items:center; }
    button { background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.06); color:#fff; padding:8px 10px; border-radius:8px; font-size:14px; }
    .hint { position:absolute; left:10px; bottom:10px; right:10px; text-align:center; color:rgba(255,255,255,0.7); font-size:13px; }
    .small { font-size:12px; opacity:0.9; }
</style>
</head>
<body>
<div id="wrapper">
    <canvas id="c"></canvas>
    <div class="ui">
        <button id="permBtn">Enable Tilt</button>
        <button id="resetBtn">Reset</button>
    </div>
    <div class="hint small">Tilt your phone/tablet to roll the marble. Drag on desktop to nudge.</div>
</div>

<script>
(() => {
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d', { alpha: false });
    const permBtn = document.getElementById('permBtn');
    const resetBtn = document.getElementById('resetBtn');

    // Logical resolution (will scale with devicePixelRatio)
    let W = 600, H = 600;
    let DPR = Math.max(1, window.devicePixelRatio || 1);

    function resize() {
        const rect = canvas.getBoundingClientRect();
        DPR = Math.max(1, window.devicePixelRatio || 1);
        canvas.width = Math.round(rect.width * DPR);
        canvas.height = Math.round(rect.height * DPR);
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        W = rect.width;
        H = rect.height;
        // recompute ball radius relative to size
        ball.r = Math.max(10, Math.min(W, H) * 0.05);
    }
    new ResizeObserver(resize).observe(canvas);
    resize();

    // Physics state
    const ball = {
        x: W/2, y: H/2,
        vx: 0, vy: 0,
        r: Math.max(10, Math.min(W, H) * 0.05),
        color: '#f2f5ff'
    };

    // Gravity vector from device (pixels/s^2)
    const G_M_PER_S2 = 9.81;
    // scale: how many pixels = 1 meter (tweak for feel)
    let pxPerMeter = Math.max(200, Math.min(W, H) * 0.8); // responsive
    let gravity = { x: 0, y: 0 }; // in pixels/s^2

    let last = performance.now();

    // Physics parameters
    const damping = 3.0;      // linear drag coefficient (per second). higher -> stops faster
    const restitution = 0.6;  // bounce energy retained on wall hit
    const floorFriction = 0.02; // small surface friction applied each frame

    // Sensor handling
    let useDevice = false;

    function handleDeviceOrientation(e) {
        // e.beta: front-back tilt [-180,180], positive forward (top down)
        // e.gamma: left-right tilt [-90,90], positive right tilt
        const beta = e.beta ?? 0;
        const gamma = e.gamma ?? 0;
        // Convert degrees to radians then compute acceleration as g * sin(angle)
        const by = Math.sin(beta * Math.PI / 180);
        const gx = Math.sin(gamma * Math.PI / 180);
        gravity.x = G_M_PER_S2 * gx * pxPerMeter;
        gravity.y = G_M_PER_S2 * by * pxPerMeter;
    }

    // Permission request for iOS 13+ devices
    permBtn.addEventListener('click', async () => {
        // try DeviceOrientationEvent.requestPermission if available
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            try {
                const res = await DeviceOrientationEvent.requestPermission();
                if (res === 'granted') {
                    window.addEventListener('deviceorientation', handleDeviceOrientation, true);
                    useDevice = true;
                    permBtn.style.display = 'none';
                } else {
                    alert('Tilt permission denied.');
                }
            } catch (err) {
                alert('Permission error: ' + err);
            }
        } else {
            // Non-iOS: just attach listener
            window.addEventListener('deviceorientation', handleDeviceOrientation, true);
            useDevice = true;
            permBtn.style.display = 'none';
        }
    });

    // Desktop / fallback: pointer drag to nudge ball or set a temporary gravity
    let dragging = false;
    let lastPointer = null;
    canvas.addEventListener('pointerdown', (ev) => {
        dragging = true;
        canvas.setPointerCapture(ev.pointerId);
        lastPointer = { x: ev.clientX, y: ev.clientY, t: performance.now() };
    });
    canvas.addEventListener('pointermove', (ev) => {
        if (!dragging) return;
        const now = performance.now();
        const dt = Math.max(1, now - lastPointer.t) / 1000;
        const dx = (ev.clientX - lastPointer.x);
        const dy = (ev.clientY - lastPointer.y);
        // apply impulse to ball proportional to pointer movement
        ball.vx += dx / Math.max(1, dt) * 0.01;
        ball.vy += dy / Math.max(1, dt) * 0.01;
        lastPointer = { x: ev.clientX, y: ev.clientY, t: now };
    });
    canvas.addEventListener('pointerup', (ev) => {
        dragging = false;
        lastPointer = null;
    });
    canvas.addEventListener('pointercancel', () => { dragging = false; lastPointer = null; });

    // Touch double-tap to reset
    let lastTap = 0;
    canvas.addEventListener('touchstart', (ev) => {
        const t = performance.now();
        if (t - lastTap < 300) resetBall();
        lastTap = t;
    });

    // Reset button
    resetBtn.addEventListener('click', resetBall);
    function resetBall() {
        ball.x = W/2; ball.y = H/2;
        ball.vx = 0; ball.vy = 0;
    }

    // Animation loop
    function step(now) {
        const dt = Math.min(0.05, (now - last) / 1000); // clamp dt
        last = now;

        // update physical pixel scale if canvas resized
        pxPerMeter = Math.max(120, Math.min(W, H) * 0.8);

        // Integrate using simple damped acceleration: dv/dt = a - k*v
        // a = gravity vector (pixels/s^2)
        ball.vx += (gravity.x - damping * ball.vx) * dt;
        ball.vy += (gravity.y - damping * ball.vy) * dt;

        // small surface friction to slow when stationary
        ball.vx *= (1 - floorFriction * dt * 60);
        ball.vy *= (1 - floorFriction * dt * 60);

        ball.x += ball.vx * dt;
        ball.y += ball.vy * dt;

        // collisions with walls (keep inside canvas)
        if (ball.x - ball.r < 0) {
            ball.x = ball.r;
            ball.vx = -ball.vx * restitution;
            // slight tangential damp
            ball.vy *= 0.98;
        } else if (ball.x + ball.r > W) {
            ball.x = W - ball.r;
            ball.vx = -ball.vx * restitution;
            ball.vy *= 0.98;
        }
        if (ball.y - ball.r < 0) {
            ball.y = ball.r;
            ball.vy = -ball.vy * restitution;
            ball.vx *= 0.98;
        } else if (ball.y + ball.r > H) {
            ball.y = H - ball.r;
            ball.vy = -ball.vy * restitution;
            ball.vx *= 0.98;
        }

        draw();

        requestAnimationFrame(step);
    }

    // Rendering
    function draw() {
        ctx.clearRect(0,0,W,H);

        // subtle grid / floor
        const grd = ctx.createLinearGradient(0,0,0,H);
        grd.addColorStop(0,'rgba(255,255,255,0.02)');
        grd.addColorStop(1,'rgba(0,0,0,0.08)');
        ctx.fillStyle = grd;
        roundRect(ctx, 0, 0, W, H, 14);
        ctx.fill();

        // draw walls (inner inset)
        ctx.save();
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'rgba(255,255,255,0.04)';
        roundRect(ctx, 6, 6, W-12, H-12, 12);
        ctx.stroke();
        ctx.restore();

        // shadow
        const shadowOffset = Math.min(12, ball.r * 0.7);
        ctx.beginPath();
        ctx.ellipse(ball.x + shadowOffset*0.25, ball.y + shadowOffset*0.6, ball.r*0.9, ball.r*0.35, 0, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(0,0,0,0.45)';
        ctx.fill();

        // ball lighting
        const rad = ctx.createRadialGradient(ball.x - ball.r*0.4, ball.y - ball.r*0.45, ball.r*0.2, ball.x, ball.y, ball.r);
        rad.addColorStop(0, '#ffffff');
        rad.addColorStop(0.15, '#dfe8ff');
        rad.addColorStop(0.6, ball.color);
        rad.addColorStop(1, '#4b6bff');
        ctx.fillStyle = rad;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
        ctx.fill();

        // highlight rim
        ctx.beginPath();
        ctx.arc(ball.x - ball.r*0.15, ball.y - ball.r*0.25, ball.r*0.35, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(255,255,255,0.4)';
        ctx.fill();

        // small velocity debug (tiny)
        // draw center dot
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, 1, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.fill();
    }

    // rounded rect helper
    function roundRect(ctx,x,y,w,h,r){
        ctx.beginPath();
        ctx.moveTo(x+r,y);
        ctx.arcTo(x+w,y,x+w,y+h,r);
        ctx.arcTo(x+w,y+h,x,y+h,r);
        ctx.arcTo(x,y+h,x,y,r);
        ctx.arcTo(x,y,x+w,y,r);
        ctx.closePath();
    }

    // Start animation
    requestAnimationFrame((t)=>{ last = t; requestAnimationFrame(step); });

    // If device orientation is already available on non-iOS, attach automatically
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission !== 'function') {
        // non-iOS: can attach immediately but require user gesture on some browsers; still fine to attach
        window.addEventListener('deviceorientation', handleDeviceOrientation, true);
        permBtn.style.display = 'none'; // hide permission button for most non-iOS devices
    }

    // Make sure ball responds to resize (center)
    window.addEventListener('resize', () => {
        // reposition ball proportionally to new size
        ball.x = Math.min(Math.max(ball.x, ball.r), W - ball.r);
        ball.y = Math.min(Math.max(ball.y, ball.r), H - ball.r);
        // delay recompute via resize observer
        setTimeout(() => { ball.r = Math.max(10, Math.min(W, H) * 0.05); }, 50);
    });

})();
</script>
</body>
</html>